<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Server Architecture</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; }
        h1, h2, h3, h4 { color: #333; }
        code { background-color: #f4f4f4; padding: 2px 4px; border-radius: 4px; font-family: monospace; }
        pre { background-color: #f4f4f4; padding: 1em; border-radius: 4px; overflow-x: auto; }
        .container { max-width: 960px; margin: 0 auto; }
        .mermaid { text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>How the Key-Value Server Works</h1>

        <h2>1. Technology Stack</h2>
        <p>The server implements a high-performance key-value store utilizing C++, PostgreSQL, and Redis. The primary design goal is to provide fast and reliable data storage and retrieval.</p>

        <h3>1.1. PostgreSQL: The Main Database</h3>
        <p>PostgreSQL serves as the server's primary database, providing persistent storage for all data. As a robust and reliable database, it ensures data integrity even in the event of a server failure or restart. All data is written to PostgreSQL, guaranteeing its durability.</p>

        <h3>1.2. Redis: The Super-Fast Cache</h3>
        <p>Redis functions as a high-speed in-memory cache. When a client requests data, the server first queries Redis. If the data is present in the cache (a "cache hit"), it is returned immediately, resulting in significantly lower latency than retrieving it from PostgreSQL.</p>
        <p>If the data is not in Redis (a "cache miss"), the server retrieves it from PostgreSQL, returns it to the client, and stores a copy in Redis for subsequent requests. To manage memory usage, Redis is configured with an eviction policy to remove less frequently accessed data, ensuring space is available for new entries.</p>

        <h3>1.3. How It All Comes Together</h3>
        <p>Several libraries are utilized to enable communication between the C++ application, PostgreSQL, and Redis. The <code>Dockerfile</code> contains all the necessary instructions to configure the environment automatically.</p>
        <ul>
            <li><strong>cpp-httplib:</strong> This is a simple C++ library used to build the actual web server that listens for requests.</li>
            <li><strong>libpq:</strong> This is the official library for connecting the C++ code to the Postgres database.</li>
            <li><strong>redis-plus-plus:</strong> This is the library used to connect the C++ code to Redis.</li>
        </ul>
        <p>The command to build the project looks like this. It tells the computer to compile the C++ code and link all these libraries together:</p>
        <pre><code>g++ serverWithCaching.cpp -o kv_server -I/opt/cpp-httplib ... -lpq -lhiredis -lredis++ -pthread</code></pre>

        <h2>2. How Data Flows</h2>
        
        <h3>2.1. The Simple Version (Without Caching)</h3>
        <div class="mermaid">
            graph TD;
                A[Client] --> B(The C++ Server);
                B --> C{What do you want to do?};
                C -- GET --> D[Ask Postgres for the data];
                D --> B;
                C -- SET --> E[Save the data in Postgres];
                E --> B;
                C -- DELETE --> F[Delete the data in Postgres];
                F --> B;
                B --> A[Client];
        </div>
        
        <h3>2.2. The Fast Version (With Caching)</h3>
        <div class="mermaid">
            graph TD;
                A[Client] --> B(The C++ Server);
                B --> C{What do you want to do?};
                C -- GET --> G{Check Redis first};
                G -- Found it! --> B;
                G -- Not there... --> D[Ask Postgres for the data];
                D --> H[Save it in Redis for next time];
                H --> B;
                C -- SET --> E[Save the data in Postgres];
                E --> I[Also save it in Redis];
                I --> B;
                C -- DELETE --> J[Delete the data in Postgres];
                J --> K[Also delete it from Redis];
                K --> B;
                B --> A[Client];
        </div>
        
        <h2>3. A Look at the Code</h2>
        <h3>3.1. <code>server.cpp</code> (The Basic Server)</h3>
        <p>This is the simple version of the server. It connects to Postgres and has three main jobs:</p>
        <ul>
            <li><code>/put</code>: Saves or updates a key-value pair.</li>
            <li><code>/get</code>: Gets the value for a key.</li>
            <li><code>/delete</code>: Removes a key-value pair.</li>
        </ul>

        <h3>3.2. <code>serverWithCaching.cpp</code> (The Fast Server)</h3>
        <p>This is the upgraded version. It performs all functions of the basic server, but it also uses Redis to make things faster.</p>
        <ul>
            <li><code>/put</code>: When you save data, it writes it to Redis *and* Postgres at the same time. This is called a "write-through" strategy.</li>
            <li><code>/get</code>: When you ask for data, it checks Redis first. If it's not there, it gets it from Postgres and then saves it to Redis for the future.</li>
            <li><code>/delete</code>: When you delete data, it removes it from both Redis and Postgres.</li>
        </ul>

        <h2>4. How the Server Handles Many Requests at Once (Multi-threading)</h2>
        <p>What if hundreds of people try to use the server at the exact same time? It would be really slow if it only handled one request at a time. To solve this, the server uses multi-threading, which is like having multiple workers to handle requests simultaneously.</p>
        
        <h3>4.1. The Thread Pool</h3>
        <p>The server is designed to handle multiple concurrent requests efficiently. To achieve this, it utilizes a multi-threading model. The <code>cpp-httplib</code> library is configured to create a <strong>thread pool</strong> with a fixed number of threads (e.g., 8), as shown in the code below:</p>
        <pre><code>svr.new_task_queue = [] { return new ThreadPool(8); };</code></pre>
        <p>When a new request (such as a <code>/get</code> or <code>/put</code> operation) is received, it is placed in a task queue. A free thread from the pool will then pick up the task and process it. This allows the server to handle up to 8 requests simultaneously, significantly improving its throughput and responsiveness.</p>

        <h3>4.2. Concurrency Control: The Database Lock</h3>
        <p>While multi-threading improves performance, it also introduces the risk of race conditions, where multiple threads attempt to access or modify the same resource simultaneously, potentially leading to data corruption. To prevent this, a synchronization mechanism called a <strong>mutex</strong> (mutual exclusion) is employed.</p>
        <p>Before a thread can perform a database operation, it must acquire the mutex. The mutex ensures that only one thread can access the database at a time. Any other threads attempting to acquire the mutex will be blocked until the current thread releases the lock. This guarantees that database operations are executed atomically and in an orderly manner, even under high concurrency.</p>
        <p>The following line of code demonstrates the use of a mutex to protect database operations:</p>
        <pre><code>std::lock_guard<std::mutex> lock(db_mutex);</code></pre>
        <p>This ensures that the database operations are thread-safe. The Redis library used in this project is inherently thread-safe, so an explicit mutex is not required for Redis operations.</p>
        
        <h2>5. How to Use It (API Examples)</h2>
        <p>The following examples demonstrate how to interact with the server using a command-line tool such as <code>curl</code>.</p>

        <h3>5.1. Save Some Data</h3>
        <pre><code>curl -X POST -d "key=mykey&value=myvalue" http://localhost:8080/put</code></pre>
        
        <h3>5.2. Get the Data Back</h3>
        <pre><code>curl "http://localhost:8080/get?key=mykey"</code></pre>
        
        <h3>5.3. Delete the Data</h3>
        <pre><code>curl -X DELETE "http://localhost:8080/delete?key=mykey"</code></pre>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
</body>
</html>
